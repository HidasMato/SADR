{"version":3,"file":"result.js","sourceRoot":"","sources":["../../src/result.ts"],"names":[],"mappings":"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","sourcesContent":["import { DatabaseError } from './protocol.js';\n\ntype Resolution = null | string;\ntype Callback<T> = (item: T) => void;\ntype ResultHandler = (\n    resolve: Callback<Resolution>,\n    reject: Callback<Error | DatabaseError>,\n) => void;\n\n/** The default result type, used if no generic type parameter is specified. */\nexport type ResultRecord<T = any> = Record<string, T>;\n\nfunction makeRecord<T>(names: string[], data: ReadonlyArray<any>): T {\n    const result: Record<string, any> = {};\n    names.forEach((key, j) => (result[key] = data[j]));\n    return result as T;\n}\n\nclass ResultRowImpl<T> extends Array<any> {\n    #names?: string[];\n    #lookup?: Map<keyof T, number>;\n\n    set(names: string[], lookup: Map<keyof T, number>, values: any[]) {\n        this.#names = names;\n        this.#lookup = lookup;\n        this.push(...values);\n    }\n\n    /**\n     * Return value for the provided column name.\n     */\n    get<K extends string & keyof T>(name: keyof T): T[K] {\n        const i = this.#lookup?.get(name);\n        if (i === undefined)\n            throw new Error(`Invalid column name: ${String(name)}`);\n        return this[i];\n    }\n\n    /**\n     * Return an object mapping column names to values.\n     */\n    reify() {\n        if (this.#names === undefined)\n            throw new Error('Column names not available');\n        return makeRecord<T>(this.#names, this);\n    }\n}\n\n/**\n * A result row provides access to data for a single row, extending an array.\n * @interface\n *\n * The generic type parameter is carried over from the query method.\n *\n * To retrieve a column value by name use the {@link get} method; or use {@link reify} to convert\n * the row into an object.\n *\n */\nexport type ResultRow<T> = ReadonlyArray<T> &\n    Pick<ResultRowImpl<T>, 'get' | 'reify'>;\n\n/**\n * The awaited query result.\n *\n * Iterating over the result yields objects of the generic type parameter.\n */\nexport class Result<T = ResultRecord> {\n    constructor(\n        public names: string[],\n        public rows: ResultRow<T>[],\n        public status: null | string,\n    ) {}\n\n    [Symbol.iterator](): Iterator<T> {\n        let i = 0;\n\n        const rows = this.rows;\n        const length = rows.length;\n        const names = this.names;\n\n        const shift = () => {\n            const data = rows[i++];\n            return makeRecord<T>(names, data);\n        };\n\n        return {\n            next: () => {\n                if (i === length) return { done: true, value: undefined! };\n                return { done: false, value: shift() };\n            },\n        };\n    }\n}\n\n/**\n * The query result iterator.\n *\n * Iterating asynchronously yields objects of the generic type parameter.\n */\nclass ResultIteratorImpl<T> extends Promise<Result<T>> {\n    private subscribers: ((\n        done: boolean,\n        error?: string | DatabaseError | Error,\n    ) => void)[] = [];\n    private done = false;\n\n    constructor(\n        private names: string[],\n        private data: any[][],\n        executor: ResultHandler,\n    ) {\n        super((resolve, reject) => {\n            executor((status) => {\n                const names = this.names || [];\n                const data = this.data || [];\n\n                const lookup: Map<keyof T, number> = new Map();\n                let i = 0;\n                for (const name of names) {\n                    lookup.set(name as keyof T, i);\n                    i++;\n                }\n\n                resolve(\n                    new Result(\n                        names,\n                        data.map((values) => {\n                            const row = new ResultRowImpl<T>();\n                            row.set(names, lookup, values);\n                            return row;\n                        }),\n                        status,\n                    ),\n                );\n            }, reject);\n        });\n    }\n\n    /**\n     * Return the first item (if any) from the query results.\n     */\n    async first() {\n        for await (const row of this) {\n            return row;\n        }\n    }\n\n    /**\n     * Return the first item from the query results, or throw an error.\n     */\n    async one() {\n        for await (const row of this) {\n            return row;\n        }\n        throw new Error('Query returned an empty result');\n    }\n\n    notify(done: boolean, status?: string | DatabaseError | Error) {\n        if (done) this.done = true;\n        for (const subscriber of this.subscribers) subscriber(done, status);\n        this.subscribers.length = 0;\n    }\n\n    [Symbol.asyncIterator](): AsyncIterator<T> {\n        let i = 0;\n\n        //const container = this.container;\n\n        const shift = () => {\n            const names = this.names;\n            const values = this.data[i];\n            i++;\n\n            if (names === null) {\n                throw new Error('Column name mapping missing.');\n            }\n\n            return makeRecord<T>(names, values);\n        };\n\n        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */\n        let error: any = null;\n\n        this.catch((reason) => {\n            error = new Error(reason);\n        });\n\n        return {\n            next: async () => {\n                if (error) {\n                    throw error;\n                }\n\n                if (this.data.length <= i) {\n                    if (this.done) {\n                        return { done: true, value: undefined! };\n                    }\n\n                    if (\n                        await new Promise<boolean>((resolve, reject) => {\n                            this.subscribers.push((done, status) => {\n                                if (typeof status !== 'undefined') {\n                                    reject(status);\n                                } else {\n                                    resolve(done);\n                                }\n                            });\n                        })\n                    ) {\n                        return { done: true, value: undefined! };\n                    }\n                }\n\n                return { value: shift(), done: false };\n            },\n        };\n    }\n}\n\nexport type DataHandler = Callback<any[] | Resolution | Error>;\n\nexport type NameHandler = Callback<string[]>;\n\nResultIteratorImpl.prototype.constructor = Promise;\n\nexport interface ResultIterator<T> extends ResultIteratorImpl<T> {\n\n}\n\nexport function makeResult<T>(transform?: (name: string) => string) {\n    let dataHandler: DataHandler | null = null;\n\n    const names: string[] = [];\n    const rows: any[][] = [];\n\n    const p = new ResultIteratorImpl<T>(names, rows, (resolve, reject) => {\n        dataHandler = (row: any[] | Resolution | Error) => {\n            if (row === null || typeof row === 'string') {\n                resolve(row);\n                p.notify(true);\n            } else if (Array.isArray(row)) {\n                rows.push(row);\n                p.notify(false);\n            } else {\n                reject(row);\n                p.notify(true, row);\n            }\n        };\n    });\n\n    const nameHandler = (ns: string[]) => {\n        names.length = 0;\n        if (transform) {\n            ns = ns.map(transform);\n        }\n        names.push(...ns);\n    };\n\n    return {\n        iterator: p,\n        dataHandler: dataHandler!,\n        nameHandler: nameHandler,\n    };\n}\n"]}