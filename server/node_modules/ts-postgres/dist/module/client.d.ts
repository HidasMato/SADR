/// <reference types="node" resolution-mode="require"/>
/// <reference types="node" resolution-mode="require"/>
/// <reference types="node" resolution-mode="require"/>
import { Writable } from 'node:stream';
import { ConnectionOptions } from 'node:tls';
import { postgresqlErrorCodes } from './errors.js';
import { Query } from './query.js';
import { ResultIterator, ResultRecord } from './result.js';
import { ClientConnectionDefaults, ClientConnectionOptions, DatabaseError, ErrorLevel, TransactionStatus } from './protocol.js';
import { DataFormat, DataType, ValueTypeReader } from './types.js';
export interface ConnectionInfo {
    encrypted: boolean;
    parameters: ReadonlyMap<string, string>;
}
export interface ClientNotice extends DatabaseError {
    level: ErrorLevel;
    code: keyof typeof postgresqlErrorCodes;
    message: string;
}
export interface DataTypeError {
    dataType: DataType;
    value: any;
}
export declare enum SSLMode {
    Disable = "disable",
    Prefer = "prefer",
    Require = "require"
}
export interface SSL {
    mode: SSLMode.Prefer | SSLMode.Require;
    options?: ConnectionOptions;
}
export interface Configuration extends Partial<ClientConnectionDefaults & ClientConnectionOptions> {
    user?: string;
    database?: string;
    host?: string;
    port?: number;
    password?: string;
    types?: Map<DataType, ValueTypeReader>;
    bigints?: boolean;
    keepAlive?: boolean;
    preparedStatementPrefix?: string;
    connectionTimeout?: number;
    ssl?: SSLMode.Disable | SSL;
}
export interface Notification {
    processId: number;
    channel: string;
    payload: string;
}
export interface PreparedStatement<T = ResultRecord> extends AsyncDisposable {
    close: (portal?: string) => Promise<void>;
    execute: (values?: any[], portal?: string, format?: DataFormat | DataFormat[], streams?: Record<string, Writable>) => ResultIterator<T>;
}
export type EventMap<T = {
    error: DatabaseError;
    notice: ClientNotice;
    notification: Notification;
}> = {
    [K in keyof T]: [T[K]];
};
export type EventListener<K> = K extends keyof EventMap ? ((...args: EventMap[K]) => void) : never;
export declare class ClientImpl {
    readonly config: Configuration;
    private readonly events;
    private connected;
    private error;
    private ending?;
    private connecting?;
    private readonly encoding;
    private readonly writer;
    private readonly clientNonce;
    private serverSignature;
    private expect;
    private stream;
    private mustDrain;
    private activeRow;
    private bindQueue;
    private closeHandlerQueue;
    private cleanupQueue;
    private errorHandlerQueue;
    private preFlightQueue;
    private rowDescriptionQueue;
    private parameterDescriptionQueue;
    private nextPreparedStatementId;
    private activeDataHandlerInfo;
    private readonly parameters;
    closed: boolean;
    processId: number | null;
    secretKey: number | null;
    transactionStatus: TransactionStatus | null;
    /**
     * @param config - An optional configuration object, comprised of connection details
     *     and client configuration. Most of the connection details can also be specified
     *     using environment variables, see {@link Environment}.
     */
    constructor(config?: Configuration);
    private startup;
    private receive;
    connect(): Promise<ConnectionInfo>;
    /** End the database connection.
     *
     */
    end(): Promise<void>;
    on<K extends keyof EventMap>(event: K, listener: EventListener<K>): void;
    off<K extends keyof EventMap>(event: K, listener: EventListener<K>): void;
    /** Prepare a statement for later execution.
     *
     * @returns A prepared statement object.
     */
    prepare<T = ResultRecord>(text: Query | string): Promise<PreparedStatement<T>>;
    /**
     * Send a query to the database.
     *
     * The query string is given as the first argument, or pass a {@link Query}
     * object which provides more control.
     *
     * @param text - The query string, or pass a {@link Query}
     *     object which provides more control (including streaming values into a socket).
     * @param values - The query parameters, corresponding to $1, $2, etc.
     * @returns A promise for the query results.
     */
    query<T = ResultRecord>(text: Query | string, values?: any[]): ResultIterator<T>;
    private bindAndExecute;
    private handleError;
    [Symbol.asyncDispose](): Promise<void>;
    private send;
    private sendUsing;
    private parseError;
    private handle;
}
