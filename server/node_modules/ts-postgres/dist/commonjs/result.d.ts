import { DatabaseError } from './protocol.js';
type Resolution = null | string;
type Callback<T> = (item: T) => void;
type ResultHandler = (resolve: Callback<Resolution>, reject: Callback<Error | DatabaseError>) => void;
/** The default result type, used if no generic type parameter is specified. */
export type ResultRecord<T = any> = Record<string, T>;
declare class ResultRowImpl<T> extends Array<any> {
    #private;
    set(names: string[], lookup: Map<keyof T, number>, values: any[]): void;
    /**
     * Return value for the provided column name.
     */
    get<K extends string & keyof T>(name: keyof T): T[K];
    /**
     * Return an object mapping column names to values.
     */
    reify(): T;
}
/**
 * A result row provides access to data for a single row, extending an array.
 * @interface
 *
 * The generic type parameter is carried over from the query method.
 *
 * To retrieve a column value by name use the {@link get} method; or use {@link reify} to convert
 * the row into an object.
 *
 */
export type ResultRow<T> = ReadonlyArray<T> & Pick<ResultRowImpl<T>, 'get' | 'reify'>;
/**
 * The awaited query result.
 *
 * Iterating over the result yields objects of the generic type parameter.
 */
export declare class Result<T = ResultRecord> {
    names: string[];
    rows: ResultRow<T>[];
    status: null | string;
    constructor(names: string[], rows: ResultRow<T>[], status: null | string);
    [Symbol.iterator](): Iterator<T>;
}
/**
 * The query result iterator.
 *
 * Iterating asynchronously yields objects of the generic type parameter.
 */
declare class ResultIteratorImpl<T> extends Promise<Result<T>> {
    private names;
    private data;
    private subscribers;
    private done;
    constructor(names: string[], data: any[][], executor: ResultHandler);
    /**
     * Return the first item (if any) from the query results.
     */
    first(): Promise<T | undefined>;
    /**
     * Return the first item from the query results, or throw an error.
     */
    one(): Promise<T>;
    notify(done: boolean, status?: string | DatabaseError | Error): void;
    [Symbol.asyncIterator](): AsyncIterator<T>;
}
export type DataHandler = Callback<any[] | Resolution | Error>;
export type NameHandler = Callback<string[]>;
export interface ResultIterator<T> extends ResultIteratorImpl<T> {
}
export declare function makeResult<T>(transform?: (name: string) => string): {
    iterator: ResultIteratorImpl<T>;
    dataHandler: DataHandler;
    nameHandler: (ns: string[]) => void;
};
export {};
