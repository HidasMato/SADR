{"version":3,"file":"sasl.js","sourceRoot":"","sources":["../../src/sasl.ts"],"names":[],"mappings":"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","sourcesContent":["import { createHash, createHmac, BinaryLike } from 'node:crypto';\nimport { Buffer } from 'node:buffer';\n\nexport function xorBuffers(a: Buffer, b: Buffer): Buffer {\n    if (a.length !== b.length) {\n        throw new Error('Buffer length mismatch');\n    }\n    if (a.length === 0 || b.length === 0) {\n        throw new Error('Buffers cannot be empty');\n    }\n    return Buffer.from(a.map((_, i) => a[i] ^ b[i]));\n}\n\nexport function hmacSha256(key: BinaryLike, msg: Buffer | string) {\n    return createHmac('sha256', key).update(msg).digest();\n}\n\nexport function sha256(key: Buffer): Buffer {\n    return createHash('sha256').update(key).digest();\n}\n\nexport function hi(password: string, saltBytes: Buffer, iterations: number) {\n    let ui1 = hmacSha256(\n        password,\n        Buffer.concat([saltBytes, Buffer.from([0, 0, 0, 1])]),\n    );\n    let ui = ui1;\n    for (let i = 0; i < iterations - 1; i++) {\n        ui1 = hmacSha256(password, ui1);\n        ui = xorBuffers(ui, ui1);\n    }\n    return ui;\n}\n\nexport function sign(\n    data: string,\n    password: string,\n    clientNonce: string,\n): [string, string] {\n    const m = Object.fromEntries(\n        data.split(',').map((attr) => [attr[0], attr.substring(2)]),\n    );\n\n    if (!(m.i && m.r && m.s)) throw new Error('SASL message parse error');\n\n    const nonce = m.r;\n\n    if (!nonce.startsWith(clientNonce)) throw new Error('SASL nonce mismatch');\n    if (nonce.length === clientNonce.length)\n        throw new Error('SASL nonce too short');\n\n    const iterations = parseInt(m.i, 10);\n    const salt = Buffer.from(m.s, 'base64');\n    const saltedPassword = hi(password, salt, iterations);\n\n    const clientKey = hmacSha256(saltedPassword, 'Client Key');\n    const storedKey = sha256(clientKey);\n\n    const clientFinalMessageWithoutProof = 'c=biws,r=' + nonce;\n    const clientFirstMessageBare = 'n=*,r=' + clientNonce;\n    const serverFirstMessage = data;\n\n    const authMessage =\n        clientFirstMessageBare +\n        ',' +\n        serverFirstMessage +\n        ',' +\n        clientFinalMessageWithoutProof;\n\n    const clientSignature = hmacSha256(storedKey, authMessage);\n    const clientProofBytes = xorBuffers(clientKey, clientSignature);\n    const clientProof = clientProofBytes.toString('base64');\n\n    const serverKey = hmacSha256(saltedPassword, 'Server Key');\n    const serverSignatureBytes = hmacSha256(serverKey, authMessage);\n\n    const response = clientFinalMessageWithoutProof + ',p=' + clientProof;\n    const serverSignature = serverSignatureBytes.toString('base64');\n    return [response, serverSignature];\n}\n"]}